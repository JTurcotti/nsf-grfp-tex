\documentclass{nsf-grfp}

\usepackage{lipsum}

\usepackage{setspace}

\title{Personal Statement}
\author{Joshua Turcotti}

\begin{document}

\maketitle
\setstretch{1.25}

\section*{Introduction and Background}

My love for the formal and rigorous began with math competitions in middle and high school, which I enjoyed because they were the most challenging experiences of my life so far. In high school, I also discovered Computer Science, and immediately loved the ways entire universes of behavior could be spawned from the most concise descriptions. It wasn't until I started undergraduate studies at UC Berkeley that I realized that the impact of Computer Science could exceed toy, formal universes, and be a tool for technology and progress in the real world. My first year of coursework at Berkeley was still very abstract - my "linear algebra" professor decided to go coordinate-free and our first topic was the universal property of free vector spaces - so this realization came the summer after my Freshman year, when I interned at a company called Splunk in San Francisco whose core product is a search engine over log files. It was a thrilling experience. I'd never seen a really large codebase before, and I saw my first one as a labyrinth and a lifeform. The small projects I was given ownership of escalated from bug fixes and trivial feature additions to wishlist-level rebuildings of prevalent abstraction layers. Even at the bugfix level, I was so excited to work on them that I'd have to Uber back home to Berkeley a couple times a week; the busses stopped running at midnight. 

Now I understand that what excited me so much about that summer was that I'd discovered one of the fundamental joys of Computer Science; the complexity of a system can far exceed the complexity of its description. A kilobyte worth of text can describe an algorithm for performing nontrivial manipulation of terabytes of data! I entered my sophomore year at Berkeley convinced that I'd find happiness and satisfaction for the rest of my life as a Software Engineer, and since my internship had ended with the question of whether I was interested in full time roles starting immediately, I was pretty convinced I'd found ultimate happiness before I turned 20. Unfortunately, teaching ruined that peace and satisfaction forever.

In my sophomore year, I was a TA for Berkeley's advanced undergraduate algorithms and data structures course, CS 170. Despite taking challenging courses in Machine Learning, Systems Programming, and even a graduate course in randomized algorithms, I still found the most exciting part of my week to be figuring out how to best explain something I'd learned a year ago like the Max Flow problem or the Fast Fourier Transform to my weekly section. I realized that the process of communicating, revisiting, and collaboratively working to understand the hard problems in Computer Science made me appreciate those problems so much more than just following my nose to an implementation and moving on. I've done two more software engineering internships since Splunk, and at both I've loved the ability to contribute to a real, running product, but I know for a fact that my happiness and satisfaction is going to come from my role in a research community.

My first exposure to the field of Programming Languages was an independent project in High School in which I attempted to implement an Automated Theorem Prover for sentences in first order logic. The task was clearly far beyond my understanding of logic and algorithm design at the time, but I got exposure to a form of logic called Gentzen Systems, and loved learning about the manipulations and reductions that were individually trivial, but together constructed powerfully arbitrary proof trees. That was just a small taste of something far beyond my reach, and I didn't get my first real exposure until an undergraduate compilers course at Berkeley, which was engaging to me because it had a similar flavor, but focused too much on actual software design and implementation to really light a match. 

The spark came with a research project I became involved in through Berkeley's RISELab, advised by Mae Milano and Andrew Myers. They were developing Gallifrey, a language for geodistributed computing, and needed its underlying type system worked out a little more formally than had been done in earlier outlines of the system. In particular, I was a given a proof obligation: are programs that successfully typecheck guaranteed to step to completion? In PL terminology, this is called "progress and preservation", and encoded strong guarantees of thread separation in this language. The path to proving this soundness condition led me through crash courses in type theory, linear logic, and an overflowing handful of other PL topics, each of which I was more excited to grasp than the last. It took about 6 months of nearly full time work, but I finished the proof with 70 pages of dense lemmas and casework. This proof was the first artifact that I ever contributed to PL, but the process of writing it taught me both the fundamentals of this section of the field, and it taught me how to communicate my formal ideas and collaborate with others to develop them. Seeing for myself that I was capable of this was the last push I needed to decide I was going to pursue a PhD.

Since then, I've continue my collaborations on Gallifrey. Our first attempt to submit the paper detailing the type system to OOPSLA was rejected for being underdeveloped and "unfinished", so I've worked to build software tooling to generate larger and more compelling examples of the system's power, and to make the experience of typechecking programs more streamlined to a fresh user. We are resubmitting to PLDI in November, and I think we have a great shot at publishing our results. 

I want to continue my work at Grad School because the process of building this type system and pushing it towards publication has made me a better thinker and researcher every step of the way, and I know that my ability to produce impactful results will only continue to grow if I continue to build and push. I don't know exactly where I want to study yet, but I've already wonderful exposure to the lab at Cornell through this work, and, as an example, I can see myself contributing so much working in an environment like that. One of the biggest things that has continued to shock and amaze me through the process of my work on this type system has been the enthusiasm of member of every corner of the PL community to take a look and help out. Their zeal to help us resolve problems we just couldn't see a way through has been independent of whether they stand to gain anything but gratitude, and that kind of support is exactly characteristic of what I seek in grad school. Of course, my early experiences TAing had already shown me how much I valued time spent thinking about things for longer than I ordinarily would have for the sake of discussion and development with others, but it took full immersion in a research community to isolate and appreciate that lesson. If given NSF funding, I will be able to take my excitement to any university PL lab in the country, and contribute it to help fuel the work of others, and to drive my own work towards novel results and powerful explorations. 

\section*{Intellectual Merit}
\setstretch{1.25}

I think my commitment to engagement with both industry and academia will lead to great opportunities to further the frontier of Programming Languages research. Many of my role models in the field have spent time both running research labs in industry, and holding positions at prominent universities. One of the many reasons I love PL as a field is that the results of progress in research are so directly applicable to the needs to industry, which leads to a constant flow of new and exciting problems back and forth between academia and industry. By spending time both in academia and industry as I have done so far, I will be able to bring the problems I learn about in industry to an academic setting, where through collaborations and mentorship by the leading experts at the institution of my choice, we will develop novel approaches to efficiently solving the problem, and eventually I will be in a position to bring that exact solution back to industry and evaluate its effects. This synergy is one of the most exciting parts to me about PL, and by planning my future to bring deep engagement with both sides I believe I can contribute results to PL of magnitude and merit.

My concrete plans to follow though on this begin before I even start my graduate education. Starting in January, I will be working for Uber research for 6 months to use what I've learned working on Gallifrey to build static analysis tools to improve Uber's 30 million line codebase. I will not have the same amount of devoted time to pondering and speculative investigation that I would have in an academic environment, but I will apply the intuition I've gained from having spent ample time investigating the formal problems. When I return to academia, my experiences deploying tools and analyzing their concrete impact will guide my pondering and focus it in more fruitful directions. I am confident that this is a recipe for great work.

\section*{Broader Impacts}
\setstretch{1.25}

We rely on software more with every passing year, so guarantees of safety and correctness for software translate into guarantees of physical safety, personal privacy, economic protection, and a vast array of other forms of social good. Conversely, when poor software is deployed, the consequences can take the form of inconveniences like unavailability of a transportation service or crashes of a mobile app, or they can take the form of life-threatening emergencies when deployed in the medical services or on a Boeing 737 Max. Every programming language that incorporates more sophisticated static analysis sets a standard for better guarantees of safety and correctness, and the more researchers decide to devote themselves to building safe and correct languages, the more usable these languages will become as they transition into industry usage. If I receive NSF funding, I will use it further the cause of providing the world with programming languages and static analysis tools that are intuitive and usable enough to gain adoption without sacrificing proofs of vital correctness properties. A world in which software runs with absolute faith that it will not leak personal information or err in the execution of a physical maneuver on which lives depend is a better one, and I know I could use NSF funding to help build it. 

\end{document}
