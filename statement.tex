\documentclass{nsf-grfp}

\usepackage{lipsum}

\usepackage{setspace}

\title{Personal Statement}
\author{Joshua Turcotti}

\begin{document}

\maketitle

\section*{Introduction and Background}

My love for the formal and rigorous began with math competitions in middle and high school. I'd never experienced an excitement greater than feasting on the dizzying array of mathematical constructs and conundrums that confronted me every time I opened an exam booklet, and I knew from the 6th grade I never wanted that feast to end. In high school, I also discovered Computer Science, and immediately loved the ways entire universes of behavior could be spawned from the most concise descriptions. It wasn't until I started undergraduate studies at UC Berkeley that I realized that the impact of Computer Science could far exceed toy, formal universes, and be a tool for technology and progress in the real world. My first year of coursework at Berkeley was still very abstract - my "linear algebra" professor decided to go coordinate-free and our first topic was the universal property of free vector spaces - so this realization came the summer after my Freshman year. That summer, I interned at a company called Splunk in San Francisco whose core product is a search engine over log files. It was a thrilling experience. I'd never seen a really large codebase before, and I saw my first one as a labyrinth and a lifeform. The small projects I was given ownership of escalated from bug fixes and trivial feature additions to wishlist-level rebuildings of prevalent abstraction layers. Even at the bugfix level, I was so excited to work on them that I'd have to Uber back home to Berkeley a couple times a week; the busses stopped running at midnight. 

Now I understand that what excited me so much about that summer was that I'd discovered one of the fundamental joys of Computer Science; the complexity of a system can far exceed the complexity of its description. A kilobyte worth of text can describe an algorithm for performing nontrivial manipulations of terabytes of input! The amount of data that would be processed by every line of code, the sheer number of different execution orders that I know the code would take once deployed, and just the elegant Lego-like feeling of software design made the process of working on Splunk's platform empowering and electrifying. I entered my sophomore year at Berkeley convinced that I'd find happiness and satisfaction for the rest of my life as a Software Engineer, and since my internship had ended with the question of whether I was interested in full time roles starting immediately, I was pretty convinced I'd found my ultimate happiness before I even turned 20. I still can't say I was disappointed when I found a greater happiness in teaching.

In my sophomore year, I was a TA for Berkeley's advanced undergraduate algorithms and data structures course, CS 170. Despite taking challenging courses in Machine Learning, Systems Programming, and even a graduate course in Randomized Algorithms, I still found the most exciting part of my week to be figuring out how to best explain something I'd learned a year ago like the Max Flow problem or the Fast Fourier Transform to my weekly section. I realized that the process of communicating, revisiting, and collaboratively working to understand the hard problems in Computer Science made me appreciate those problems so much more than just following my nose to an implementation and moving on. Eventually, this would be the same thing I'd appreciate in research - the pure love for simple but hard problems. I've done two more software engineering internships since Splunk, and at both I've loved the ability to contribute to a real, running product, but I know for a fact that my happiness and satisfaction is going to come from my role in a research community.

My first exposure to the field of Programming Languages was an independent project in High School, in which I attempted to implement an Automated Theorem Prover for sentences in first order logic. The task was clearly far beyond my understanding of logic and algorithm design at the time, but I got exposure to a form of logic called Gentzen Systems that struck me as the most sophisticated and harmoniously-constructed mathematical systme I'd ever seen. I loved learning about the rules for manipulations and reductions that were individually trivial, but together constructed powerfully arbitrary proof trees. That was just a small taste of something far beyond my reach, and I didn't get my first thorough exposure to PL until an undergraduate compilers course at Berkeley, which was engaging to me because it had a similar flavor, but unfortunately it focused too much on actual software design and implementation to really light a match. 

The spark came with a research project I became involved with through Berkeley's RISELab, advised by Mae Milano and Andrew Myers. They were developing Gallifrey, a language for geodistributed computing, and needed its underlying type system worked out a little more formally than had been done earlier. In particular, I was a given a proof obligation: are programs that successfully typecheck guaranteed to run without crashing? In PL terminology, this is called "progress and preservation", and encoded strong guarantees of thread separation in this language. The path to proving this soundness condition led me through crash courses in type theory, linear logic, formal verification, and an overflowing handful of other PL topics, each of which I was more excited to grasp than the last. It took about 6 months of more than full time work, but I finished the proof with 70 pages of dense lemmas and casework. This proof was the first artifact that I ever contributed to PL, but the process of writing it taught me both the fundamentals of this section of the field, and it taught me how to communicate my formal ideas and collaborate with others to develop them. Seeing for myself that I was capable of this was the last push I needed to decide I was going to pursue a PhD.

Since then, I've continued my collaborations on Gallifrey. Our first attempt to submit the paper detailing the type system to OOPSLA was rejected for being underdeveloped, so I've worked to build software tooling to generate larger and more compelling examples of the system's power, and to make the experience of typechecking programs more streamlined to a fresh user. I've also begun the process of gaining a thorough understanding of the landscape of existing work in this space, which has been overwhelming at times but ultimately refreshing, with new insight into the field at every turn. We are resubmitting to PLDI in November, and I think we have a great shot at acceptance.

I want to continue my work at Graduate School because the process of building this type system and pushing it towards publication has made me a better thinker and researcher every step of the way, and I know that my ability to produce impactful results will only continue to grow if I continue to build and push. I don't know exactly where I want to study yet, but I've already had wonderful exposure to the lab at Cornell through this work, and, as an example, I can see myself contributing so much working in as supportive and idea-rich a research environment as they've created. More generally, the enthusiasm of members of every corner of the PL community to take a look and help out with my work has shocked and amazed me throughout my research process. Their zeal to help us resolve problems we just couldn't see a way through has been independent of whether they stand to gain anything but gratitude, and that kind of support is exactly characteristic of what I seek in grad school. My early experiences TAing had already shown me how much I valued time spent thinking about hard problems for the sake of discussion and communal development instead of product-shipping, but it took full immersion in a research community to isolate and appreciate that lesson. If given NSF funding, I will be able to take my excitement to any university PL lab in the country, and contribute it to help fuel the work of others and to drive my own work towards novel results and powerful explorations. 

I have identified that industry alone will never satisfying my cravings to learn and explore, but I still am committed to spending time in industry to maintain focus and relevance in my work. Many of my role models in the field have spent time both running research labs in industry, and holding positions at prominent universities. One of the many reasons I love PL as a field is that the results of progress in research are so directly applicable to the needs to industry, which leads to a constant flow of new and exciting problems back and forth between academia and industry. By spending time both in academia and industry as I have done so far, I will be able to bring the problems I learn about in industry to an academic setting, where through collaborations and mentorship by the leading experts at the institution of my choice, we will develop novel approaches to efficiently solving the problem, and eventually I will be in a position to bring that exact solution back to industry and evaluate its effects. This synergy is one of the most exciting parts to me about PL, and by planning my future to bring deep engagement with both sides I believe I can contribute results to PL of magnitude and merit.

\section*{Intellectual Merit}

My experiences exploring the rich formal structures of mathematics and computer science began with competitions in middle school gymnasiums attended with fervent regularity, took me through self-taught crash course after crash course of programming and logic that my high school mind just couldn't enough of, and drove me to enroll in graduate Berkeley courses that have exposed me to the forefronts of research in Information Theory, Randomness, Complexity Theory, and Programming Languages. I've written tens of thousands of lines of code in school projects and industry engineering alike, and learned from accomplished mentors who led the field decades ago; energetic mentors who lead it right now; and mentors among my peers that hopefully someday will lead it themselves. My experiences teaching in one of Berkeley's most loved courses have taught me to share and to communicate. My experiences coding in rapid-fire industry deployment cycles have taught me resilience and productivity. My experiences collaborating with some of the country's finest PL research labs have taught me awe and creativity. As I continue to take on the hard problems in Programming Languages, I will remember all the lessons I've learned along the way: that excitement only grows as you push deeper into a topic you love, that you are never too deep in to engage a new set of meaningful and passionate collaborators, and that in a landscape of pursuits as dense and diverse as the field of Computer Science, there's a greater endeavor beyond every seemingly-ultimate happiness. I am more proud of nothing than being in a good position to contribute to the field of Programming Languages.

\section*{Broader Impacts}

The joy of intellectual challenge and contribution alone would be enough to motivate a lifetime of work, but there are two additional impacts of work in Programming Languages that combine with my intellectual excitement to really seal the deal: the essential role of PL in bringing work and study in computer science to new audiences, and the growing role of PL in the social goods of safety and security.

Eventually, we learn that computer science is so much more than coding; but at the beginning, those looking for an introduction to computer science are looking for an introduction to writing code. This is very rational, as baseline fluency in programming languages, especially scripting languages and languages for data science, is a massively valuable skill in the modern world. Unfortunately, programming languages are plagued with insider terminology, dated documentation, and obscure tutorials. The disconnect between the genuine passions of so many people of all ages to learn to code right now, and the inaccessibility of the languages they seek to learn to code in is alarming and disappointing. By working in PL, I'll help build languages with more intuitive abstractions and friendlier tooling that will bring coding to anyone who wants to learn it. I believe in a world in which the desire to learn gives you a right to the tools to learn, and helping ensure that our industry follows through on that right is as galvanizing a cause as I can imagine.

On a societal scope, the broader impacts of PL work are unbounded. We rely on software more with every passing year, so guarantees of safety and correctness for software translate into guarantees of physical safety, personal privacy, economic protection, and a vast array of other forms of social good. Conversely, when poor software is deployed, the consequences can take the form of inconveniences like the unavailability of a transportation service or crashes of a mobile app, or they can take the form of life-threatening emergencies when deployed in the medical services or on a Boeing 737 Max. Every programming language that incorporates more sophisticated static analysis sets a higher standard for guarantees of safety and correctness, and the more researchers that decide to devote themselves to building safe and correct languages, the more usable these languages will become, speeding their transition into industry adoption. If I receive NSF funding, I will use it to further the cause of providing the world with programming languages and static analysis tools that are intuitive and usable enough to gain adoption without sacrificing their proofs of vital correctness properties. A world in which software runs with absolute faith that it will not leak personal information or err in the execution of a physical maneuver on which lives depend is a better one, and I know I could use NSF funding to help build it. 


\end{document}
